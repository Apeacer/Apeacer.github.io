[{"title":"Java实现线程安全的单例模式方法","date":"2017-03-25T14:26:39.000Z","path":"2017/03/25/20170325ThreadSalfSingle/","text":"单例模式，也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。[以上摘自维基百科]如果一个类是单例的，那么可以保证它全局只有一个实例。通常有两种常用方式。 1.饿汉模式非常的饿，立刻就要吃东西，全局的单例实例在类装载时构建。 123456public class Singleton &#123; private final static Singleton INSTANCE = new Singleton(); public static Singleton getInstance() &#123; return INSTANCE; &#125;&#125; 由于 INSTANCE 被修饰为 private、final、static，因此属于静态绑定，在类装载时期就已经构建好。由此可以看出所以实例以线程安全的方式发布，运行时获得对象很快，但从类加载开始一直到应用结束都会占用着资源。 2.懒汉方式。非常形象，全局的单例实例直到被使用了，不构建不行了才开始构建。&gt;12345678public class Singleton &#123; private static Singleton INSTANCE = null; public static Singleton getInstance() &#123; if (null == INSTANCE) INSTANCE = new Singleton(); return INSTANCE; &#125;&#125; 它的特点是运行时第一次获得对象的速度比较慢，但加载类的时候比较快。它在整个应用的生命周期只有一部分时间在占用资源。如果应用程序本身很庞大，占用资源多，加载速度慢，那么懒汉方式的优势就比较明显了。但例子中实现的懒汉单例将构建实例的工作推迟到了运行时，在多线程下会出现问题。JVM为了提升性能，进行重排序。由于构建实例的操作不是原子的，为了简化理解，假设可以分成两个操作，即为实例内各个成员变量进行赋值的操作，和将引用变量 INSTANCE 指向实力的操作。这两个操作的顺序是不一定的，所以若A线程进入 getInstance()方法，发现实力为 null，开始进行构建，很有可能B线程进入此方法时，INSTANCE 变量不是 null，但其内部的成员变量可能还未赋值。 2.1 解决方法一：用synchronize 修饰 getInstance() 方法这种方法可以保证足够的同步与安全，但是每次使用此方法时都要获取锁，如果此方法的竞争的话，会降低触须的吞吐量。其实我们只有第一次调用此方法的时候才需要同步，因此这不是一种好的解决方案。 2.2 解决方法二：DCL(Double Check Lock)DCL代码如下，虽然看起来是一种很有效的解决方案，但事实并非如此。此方法只能保证只有一个线程对 INSTANCE 进行初始化，但并不能杜绝 synchronize 代码块内的重排序。因此当一个线程进行初始化时，第二个线程很可能在进入第一个判空时看到一个不完整的 INSTANCE 实例并返回。 1234567891011public class Singleton &#123; private static Singleton INSTANCE = null; public static Singleton getInstance() &#123; if (null == INSTANCE) synchronize(this) &#123; if (null == INSTANCE) INSTANCE = new Singleton(); &#125; return INSTANCE; &#125;&#125; 2.3 延迟加载初始化先看代码 12345678public class Singleton &#123; private static class SingletonHelper &#123; private static Singleton INSTANCE = new Singleton(); &#125; public static Singleton getInstance() &#123; return SingletonHelper.INSTANCE; &#125;&#125; 这是一种合理的线程安全懒汉模式。只有在用到 getInstance()方法时 SingletonHelper 类才会被装载并初始化。因此在初始化SingletonHelper完成时，INSTANCE 变量也会完成构建。 ####以上是我对线程安全的变量的单例模式的理解，有错误的地方还请指正，欢迎大神赐教……^_^转载请注明出处https://apeacer.github.io","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://apeacer.github.io/tags/java/"}]},{"title":"关于快速排序算法优化的研究和实现","date":"2017-03-02T11:50:06.000Z","path":"2017/03/02/20170302quckSort/","text":"今天研究了一下快速排序的优化问题，关于快速排序的优化，很多人已经有很详细的解释了，我就不多做详细的阐述，主要实现一下代码，解释一下jdk中Arrays.sort,并对比一下，做一个总结。 ###1.普通快速排序先上代码： 123456789101112131415161718public void quickSort(int[] a, int left, int right) &#123; if(left &lt; right) &#123; int pivot = partition(a, left, right); quickSort(a, left, pivot - 1); quickSort(a, pivot + 1, right); &#125;&#125;private int partition(int[] a, int left, int right) &#123; int pivot = a[left]; while(left &lt; right) &#123; while(left &lt; right &amp;&amp; a[right] &gt;= pivot) right--; a[left] = a[right]; while(left &lt; right &amp;&amp; a[left] &lt; pivot) left++; a[right] = a[left]; &#125; a[left] = pivot; return left;&#125; ###2.随机枢纽位置快速排序普通快排每次划分并递归时，找第一个(或最后一个)元素做枢纽，因此缺点很明显，当数组有序或部分有序时，每次划分只能使待排序序列减一，使算法复杂度在最差情况下为Θ(n^2)。因此可以用随机选取枢纽位置来进行划分的方式改善。 1234567891011121314151617181920// 把上面普通快排的partition换成它即可 private int randomPartition(int[] a, int left, int right) &#123; int piovtPos = getRandomPivo(left, right); int piovt = a[piovtPos]; a[piovtPos] = a[left]; while(left &lt; right) &#123; while(left &lt; right &amp;&amp; a[right] &gt;= piovt) right--; a[left] = a[right]; while(left &lt; right &amp;&amp; a[left] &lt; piovt) left++; a[right] = a[left]; &#125; a[left] = piovt; return left; &#125; Random random = new Random(); private int getRandomPivo(int left, int right)&#123;// 获取随机枢纽位置 int max = right-left+1;// [0,length) return random.nextInt(max)+left;// [left,right+1) &#125; ###3.三数取中快速排序对于随机选取枢纽元素的情况下，我们肯定希望取得的枢纽值的大小越接近中位数越好。怎样实现呢？我们可以随机取三个数用中间大小的数做枢纽元素，但这样效率不高。最佳的做法是把数组分为等长的四分，从3个分割点中取中。这样可以使枢纽元素接近中位数。 12345678910111213141516// 将上面排序中getRandomPivo方法换为此方法即可 private int getMidPivo(int[] a, int left, int right)&#123;// 获取随机枢纽位置 int m = (right+left)&gt;&gt;1;// 中间位置 int l = m - (right+left)&gt;&gt;2 // 四分之一位置 int r = m + (right+left)&gt;&gt;2 // 四分之三位置 if(a[l] &gt; a[r]) &#123;// 交换l，r，使a[l]&lt;a[r] l = l + r; r = l - r; l = l - r; &#125; if(a[m]&lt;a[l]) return l; if(a[m]&gt;a[r]) return r; retrun m; &#125; ###4.三数取中快速排序+插入排序由于快速排序的递归是要占用堆空间的，当待排序列被分割到比较小的时候，没必要继续递归而增加堆栈的深度，因此可以切换为插入排序来提高效率。因此，在代码证可以判断，当待排序列小于40的时候，切换为插入排序。 12345678910111213141516171819202122// 将quickSort方法改为如下： public void midQuickSortI(int[] a, int left, int right) &#123; if(right - left &lt; 40) &#123; insertSort(a, left, right); &#125;else if(left &lt; right) &#123; int pivot = midPartition(a, left, right); midQuickSortI(a, left, pivot - 1); midQuickSortI(a, pivot + 1, right); &#125; &#125; private void insertSort(int[] a, int left, int right) &#123;// 插入排序 for(int i = left+1; i &lt;= right; i++) &#123; int j = i; int temp = a[i];// 待插入 while(j &gt; 0 &amp;&amp; temp &lt; a[j-1]) &#123; a[j] = a[j-1]; j--; &#125; a[j] = temp; &#125; &#125; ###5.三数取中快速排序+插入排序+忽略重复虽然上面方法解决了有序数组与短数组方面的性能提升，但还有一种情况，就是如果数组中有很多的重复元素的话，那么当枢纽值为一个重复次数很多的元素时，那些跟它相等的元素本可以不再继续参与排序了的。因此，每次划分排序时移位时我们可以让与枢纽元素一样大的元素聚集在枢纽元素两侧然后下次划分时把他们全部排除在外。 下面给出终极快速排序代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public void eventualQuickSort(int[] a, int left, int right) &#123; // 小数组用插入排序 if(right - left &lt; 40) &#123; insertSort(a, left, right+1); return; &#125; //大数组递归快排 int low = left; // 保存左右边界 int hight = right; int leftSameLen = 0;// 记录左右两边与枢纽元素等大的元素个数 int rightSameLen = 0; int piovtPos = getMidPivo(a,left, right); // 三数取中枢纽位置(见上面3.代码) int piovt = a[piovtPos]; // 保存枢纽元素 a[piovtPos] = a[left]; // 先将枢纽移动到最左边 while(left &lt; right) &#123; while(left &lt; right &amp;&amp; a[right] &gt;= piovt) &#123; if(a[right] == piovt) &#123;// 将与枢纽元素等大元素移动到最右边 a[right] = a[hight-rightSameLen]; a[hight-rightSameLen] = piovt; rightSameLen ++; &#125; right--; &#125; a[left] = a[right]; while(left &lt; right &amp;&amp; a[left] &lt;= piovt) &#123; if(a[left] == piovt) &#123;// 将与枢纽元素等大元素移动到最左边 a[left] = a[low + leftSameLen]; a[low + leftSameLen] = piovt; leftSameLen ++; &#125; left++; &#125; a[right] = a[left]; &#125; a[left] = piovt;// 放回枢纽元素,最后left == right 是枢纽元素最终的位置 for (int i = 0; i &lt; rightSameLen; i++) &#123;// 将左右两边的与枢纽元素等大的元素聚集到枢纽元素两边 a[hight - i] = a[left + 1 + i]; a[left + 1 + i] = piovt; &#125; for (int j = 0; j &lt; leftSameLen; j++) &#123; a[low + j] = a[left - 1 - j]; a[left - 1 - j] = piovt; &#125; // 递归分割并继续排序 eventualQuickSort(a, low, left - leftSameLen-1); eventualQuickSort(a, left + rightSameLen+1 , hight); &#125; ###6.Arrays.sort()JDK中的Arrays.sort()用的也是优化过的快速排序，不过优化思路有部分不同。对于基本数据类型，比如int，当数组小于47时用优化过的插入排序，当数组长于47，小于286时，用多路快速排序，数组长于286时进行判断，若有大片的递增序列可用归并排序进行，否则用快排。这里的多路快排与之前的优化思路类似，选择枢纽时，先确定5个轴，e3为正中间，e1+len/7 = e2，e2+len/7 = e3, e3+len/7=e4，e4+len/7=e5，对数组中a[e1]-a[e5]进行冒泡排序。若e五个值都不等：e2，e4做轴，每次划分使数组分为三部分，(~,e1)，[e1,e2]，(e2,~)。对两边的部分进行快排，若中间部分小于len*4/7的话也进行快排，否则将与e2,e4等大元素放在e2、e4外侧，不参与快排，对中间剩余部分再继续迭代快排。若e五个值有部分相等：e3做轴用传统3-way快排，一次划分完毕后将与e3相等的元素聚集在中间不参与排序了，两边部分继续递归快排。说的可能不太清楚，具体细节得自己去查看源码呀～ ###7.总结对比接下来对每个方法进行相同的用相同的数组进行排序计算时间并比较，单位都是ms。 方法 随机数组 有序数组 重复数组 普通快速排序 130 StackOverflowError 4720 随机枢纽快排 130 61 4648 三数取中快排 133 36 4584 三数取中+插入 98 13 4573 三数取中+插入+聚集枢纽 184 77 46 Array.sort 128 16 71 其中：所有数组长度均为1000000。“随机数组”每一位均为在[0-500000)之间随机生成；“有序数组”即从第一位开始0,1,2…一直到1000000-1；“重复数组”每一位均为在[0-100)之间随机生成 由此可看出每一步优化的思路都起到了效果,jdk中的实现要更加复杂一些，但效果也更好，适用场景也更加宽泛一些。 转载请注明出处：https://apeacer.github.io参考博客:http://blog.csdn.net/insistgogo/article/details/7785038#commentshttp://www.jianshu.com/p/6d26d525bb96","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://apeacer.github.io/categories/algorithm/"}],"tags":[{"name":"sort","slug":"sort","permalink":"https://apeacer.github.io/tags/sort/"}]},{"title":"用Hexo+GitHug搭建个人博客","date":"2017-02-26T03:06:46.000Z","path":"2017/02/26/20170225_bulidHexo/","text":"通过查阅资料，一边摸索一边实践，终于通过Hexo+GitHub搭建好了一个个人博客站点，在这里分享一下，尽量说得详细，降低门槛。本分享主要针对Mac平台。首先说一下原理：首先Github Pages 是开放的公共静态页面搭建托管服务，站点可以被免费托管在Github 上，你可以使用github账户名+/github.io 域名来发布站点。Hexo将在本地生成静态页面并自动关联发布到github上 正文：GitHub相关 首先我们需要一个Github账号，用来给我们提供服务、托管站点。并建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】 然后我们要在MAC本地安装git,如果你已经安装了XCode，将自带git不必再安装。打开终端，输入下面命令，如果显示版本信息则证明安装成功。 1$ git --version 最后我们要建立关联，通过下面前两条命令配置本地git的全局用户名和邮箱，第三条命令用来显示git所有全局信息，检查用户名和邮箱是否成功配置到git。 123$ git config --global user.name \"username\"$ git config --global user.email \"email@163.com\"$ git config --list 获取Git配置信息 通过下条命令，来根据你的用户名生成sskey，一路按回车将后，在~/.ssh／目录下将生成两个文件，将其中id_rsa.pub中的内容复制到你的github主页右上角头像 –&gt; setting –&gt; SSH and GPG keys –&gt; New SSH key –&gt; Key 中并保存。这样你的本地git关联了你的GitHub账号了。 1$ ssh-keygen -t -C \"username\" 通过下面命令，之后再输入yes可以验证配置是否成功 1$ ssh git@github.com Node.js安装 用来生成静态页面，到Node.js官网下载，一路安装。通过下面命令显示版本信息检查是否安装成功 123456789$ npm -v ``` ### HEXO安装&gt; * 首先安装hexo&gt; ``` bash$ sudo npm install -g hexo 创建一个本地用来存放站点内容的目录如myBlogs，并cd到myBlogs目录下，执行下面命令进行初始化 1234$ hexo init``` &gt; * 编辑myBlogs下面的 _config.yml 如下所示：&gt; deploy: type: git repository: https://github.com/your_user_name/your_user_name.github.io.git branch: master1234&gt; * 执行下面命令后，才能使git部署&gt; ``` bash$ npm install hexo-deployer-git --save ###HEXO使用 在myBlogs目录中，/source/_posts/ 目录下存放你的文章内容，可下载Markdown编辑器进行编写。_config.yml 文件用来配置站点用户名、主题啊之类的一些全局信息。/theme/ 目录下存放你下载好的主题，主题中的_config.yml 文件里面可以修改你的头像、联系方式、友情链接之类的信息。 当你一切都配置好后便可以通过 hexo generate 命令生成静态页面。通过 hexo deploy 命令进行部署。以后每次你写完文章都可以通过下面三个命令进行部署 123$ hexo clear$ hexo generate$ hexo deploy 当然，在deploy之前，可以先用下面命令在本地调试，输入命令后，在浏览器输入http://localhost:4000，可以预览先预览你的站点。 1$ hexo server 这样博客个人站点就部署完了，可以愉快的“折腾”了～，最后hexo详细的命令解释与配置信息等请点击此处查看。欢迎一起交流学习qq：2574919263。 转载请注明出处https://apeacer.github.io/","categories":[{"name":"other","slug":"other","permalink":"https://apeacer.github.io/categories/other/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://apeacer.github.io/tags/Hexo/"},{"name":"github","slug":"github","permalink":"https://apeacer.github.io/tags/github/"}]}]